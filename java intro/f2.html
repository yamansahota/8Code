<html>

<body>

    <link href="assets/css/f1style.css" rel="stylesheet">

    <h1>Fundamental of Java </h1>
    <p>Programs written in Java have a reputation for being slower and requiring more memory than those written in C++.
        However, Java programs' execution speed improved significantly with the introduction of just-in-time compilation
        in 1997/1998 for Java 1.1, the addition of language features supporting better code analysis (such as inner
        classes, the StringBuilder class, optional assertions, etc.), and optimizations in the Java virtual machine,
        such as HotSpot becoming Sun's default JVM in 2000. With Java 1.5, the performance was improved with the
        addition of the java.util.concurrent package, including lock-free implementations of the ConcurrentMaps and
        other multi-core collections, and it was improved further with Java 1.6</p>

    <h1>Non JVM</h1>
    <p>Some platforms offer direct hardware support for Java; there are micro controllers that can run Java bytecode in
        hardware instead of a software Java virtual machine, and some ARM-based processors could have hardware support
        for executing Java bytecode through their Jazelle option, though support has mostly been dropped in current
        implementations of ARM.</p>

    <h1>Automatic memory management</h1>
    <p>

        Java uses an automatic garbage collector to manage memory in the object lifecycle. The programmer determines
        when objects are created, and the Java runtime is responsible for recovering the memory once objects are no
        longer in use. Once no references to an object remain, the unreachable memory becomes eligible to be freed
        automatically by the garbage collector. Something similar to a memory leak may still occur if a programmer's
        code holds a reference to an object that is no longer needed, typically when objects that are no longer needed
        are stored in containers that are still in use.[53] If methods for a non-existent object are called, a null
        pointer exception is thrown</p>
    <h1>Garbage Collction </h1>
    <p>One of the ideas behind Java's automatic memory management model is that programmers can be spared the burden of
        having to perform manual memory management. In some languages, memory for the creation of objects is implicitly
        allocated on the stack or explicitly allocated and deallocated from the heap. In the latter case, the
        responsibility of managing memory resides with the programmer. If the program does not deallocate an object, a
        memory leak occurs.[53] If the program attempts to access or deallocate memory that has already been
        deallocated, the result is undefined and difficult to predict, and the program is likely to become unstable or
        crash. This can be partially remedied by the use of smart pointers, but these add overhead and complexity.
        Garbage collection does not prevent logical memory leaks, i.e. those where the memory is still referenced but
        never used.</p>
    <p>Garbage collection may happen at any time. Ideally, it will occur when a program is idle. It is guaranteed to be
        triggered if there is insufficient free memory on the heap to allocate a new object; this can cause a program to
        stall momentarily. Explicit memory management is not possible in Java.

        Java does not support C/C++ style pointer arithmetic, where object addresses can be arithmetically manipulated
        (e.g. by adding or subtracting an offset). This allows the garbage collector to relocate referenced objects and
        ensures type safety and security.

        As in C++ and some other object-oriented languages, variables of Java's primitive data types are either stored
        directly in fields (for objects) or on the stack (for methods) rather than on the heap, as is commonly true for
        non-primitive data types (but see escape analysis). This was a conscious decision by Java's designers for
        performance reasons.</p>
</body>

</html>